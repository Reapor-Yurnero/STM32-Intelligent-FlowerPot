/**
  ******************************************************************************
  * @file    main.c
  * @author  fire
  * @version V1.0
  * @date    2013-xx-xx
  * @brief   摄像头火眼ov7725测试例程
  ******************************************************************************
  * @attention
  *
  * 实验平台:秉火 F103-指南者 STM32 开发板 
  * 论坛    :http://www.firebbs.cn
  * 淘宝    :https://fire-stm32.taobao.com
  *
  ******************************************************************************
  */
  
#include "stm32f10x.h"
#include "./ov7725/bsp_ov7725.h"
#include "./lcd/bsp_ili9341_lcd.h"
#include "./led/bsp_led.h"   
#include "./usart/bsp_usart.h"
#include "./key/bsp_key.h"  
#include "./systick/bsp_SysTick.h"
#include "./bh1750/bh1750.h"
#include "./bh1750/bsp_i2c_gpio.h"
#include "./dht11/bsp_dht11.h"
#include "./bmp/bsp_bmp.h"
#include "./ESP8266/bsp_esp8266.h"
#include "./base64/base64.h"
#include "ff.h"


#define DLEN 1920

/* DHT11 Data Struct */
DHT11_Data_TypeDef DHT11_Data;

ADC_InitTypeDef ADC_InitStructure;

/* extern luminance result */
extern float result_lx;

float moisture_final = 0;

/* extern vsync excep */
extern uint8_t Ov7725_vsync;

unsigned int Task_Delay[NumOfTask] = {0}; 

extern OV7725_MODE_PARAM cam_mode;
extern uint8_t mode;

extern uint32_t Minute;
extern uint32_t Second;
extern uint32_t Hour;
extern uint32_t tenUs;

// define time struct for pump recording
typedef struct {
	uint32_t hour;
	uint32_t minute;
	uint32_t second;
} Time;

Time pump_t;

FATFS fs;													/* FatFs文件系统对象 */
FIL fnew;													/* 文件对象 */
FRESULT res_sd;                /* 文件操作结果 */
UINT fnum;            					  /* 文件成功读写数量 */
BYTE ReadBuffer[1024]={0};        /* 读缓冲区 */

void Fetch_DHT11(void);
void Fetch_BH1750(void);
void ADC_INIT(void);
void Fetch_Moisture(void);
void Pump_GPIO_INIT(void);
void Drive_Pump(void); 
void EXTI_CONFIG (void);
void Save_Photo(void);
void Save_Data(void);
void Send_Photo(void);

/**
  * @brief  主函数
  * @param  无  
  * @retval 无
  */
int main(void) 	
{
	// Variables declaration and init
	int Thres_T = 25; // threshold for Temp
	float Thres_M = 10.0; // threshold for mositure
	int pump_interval = 12;  // pump_interval for watering
	static int baw = 0;  // black or white display mode
	float frame_count = 0;
	uint8_t retry = 0;
	uint8_t Pump_Enable = 1;
	uint8_t send_photo_flag = 0;
	
	mode = 0;  // video(1) or data(0) mode
	DHT11_Data.temp_int = 0;
	DHT11_Data.valid = ERROR;
	moisture_final = 100.0;
	pump_t.hour = 0;
	pump_t.minute = 0;
	pump_t.second = 0;
	
	/* Systick Initialization */
	SysTick_Init();
	
	/* LCD Init */
	ILI9341_Init();
	ILI9341_GramScan ( 3 );
	
	LCD_SetFont(&Font8x16);
	LCD_SetColors(BLACK,WHITE);

  ILI9341_Clear(0,0,LCD_X_LENGTH,LCD_Y_LENGTH);	
	
	// test lcd
  ILI9341_DispStringLine_EN(LINE(0),"BH OV7725 Test Demo");

	/* Initialize dht 11 and bh1750 */
	DHT11_GPIO_Config(); 
	Init_BH1750();
	//Fetch_BH1750();
	//Fetch_DHT11();
	//Delay_ms(5000);

	/* other init config */
	USART_Config();
	LED_GPIO_Config();
	Key_GPIO_Config();
	EXTI_CONFIG();
	Pump_GPIO_INIT();
	ESP8266_Init();
	ADC_INIT();
	
	/*mount sd card file system*/
	res_sd = f_mount(&fs,"0:",1);
	printf("chenggong!\n");
	/*----------------------- format ---------------------------*/  
	/* 如果没有文件系统就格式化创建创建文件系统 */
	if(res_sd == FR_NO_FILESYSTEM)
	{
		printf("》SD卡还没有文件系统，即将进行格式化...\r\n");
    /* 格式化 */
		res_sd=f_mkfs("0:",0,0);							
		
		if(res_sd == FR_OK)
		{
			printf("》SD卡已成功格式化文件系统。\r\n");
			ILI9341_DispStringLine_EN(LINE(1),"TF Card Formatted Successfully!");
      /* 格式化后，先取消挂载 */
			res_sd = f_mount(NULL,"0:",1);			
      /* 重新挂载	*/			
			res_sd = f_mount(&fs,"0:",1);
		}
		else
		{
			LED_RED;
			printf("《《格式化失败。》》\r\n");
			ILI9341_DispStringLine_EN(LINE(1),"TF Card Failed to be Formatted!");
			while(1);
		}
	}
  else if(res_sd!=FR_OK)
  {
    printf("！！SD卡挂载文件系统失败。(%d)\r\n",res_sd);
    printf("！！可能原因：SD卡初始化不成功。\r\n");
		ILI9341_DispStringLine_EN(LINE(1),"NO TF Card Found");
		while(1);
  }
  else
  {
    printf("》文件系统挂载成功，可以进行读写测试\r\n");
		ILI9341_DispStringLine_EN(LINE(1),"TF Card Successfully Loaded");
  }
	
	printf("\r\n ** OV7725摄像头实时液晶显示例程** \r\n"); 
	
	/* ov7725 gpio 初始化 */
	OV7725_GPIO_Config();
	
	//LED_BLUE;
	/* ov7725 寄存器默认配置初始化 */
	while(OV7725_Init() != SUCCESS)
	{
		retry++;
		if(retry>5)
		{
			printf("\r\n没有检测到OV7725摄像头\r\n");
			ILI9341_DispStringLine_EN(LINE(2),"No OV7725 module detected!");
			while(1);
		}
	}


	/*根据摄像头参数组配置模式*/
	OV7725_Special_Effect(cam_mode.effect);
	/*光照模式*/
	OV7725_Light_Mode(cam_mode.light_mode);
	/*饱和度*/
	OV7725_Color_Saturation(cam_mode.saturation);
	/*光照度*/
	OV7725_Brightness(cam_mode.brightness);
	/*对比度*/
	OV7725_Contrast(cam_mode.contrast);
	/*特殊效果*/
	OV7725_Special_Effect(cam_mode.effect);
	
	/*设置图像采样及模式大小*/
	OV7725_Window_Set(cam_mode.cam_sx,
														cam_mode.cam_sy,
														cam_mode.cam_width,
														cam_mode.cam_height,
														cam_mode.QVGA_VGA);

	/* 设置液晶扫描模式 */
	ILI9341_GramScan( cam_mode.lcd_scan );
	
	
	
	ILI9341_DispStringLine_EN(LINE(3),"OV7725 initialize success!");
	printf("\r\nOV7725摄像头初始化完成\r\n");
	
	Ov7725_vsync = 0;

	/* Setup for ESP8266 */
	ILI9341_DispStringLine_EN(LINE(4),"Setup WIFI connection!");
	if (ESP8266_SetupConnection() ) ILI9341_DispStringLine_EN(LINE(5),"WIFI connected!");
	strEsp8266_Fram_Record .InfBit .FramLength = 0;
	strEsp8266_Fram_Record .InfBit .FramFinishFlag = 0;	
	
	/*--------- User Setting GUI ------------*/
	ILI9341_Clear(0,0,LCD_X_LENGTH,LCD_Y_LENGTH);	
	ILI9341_DispStringLine_EN(LINE(0),"Choose your plant:");
	ILI9341_DispStringLine_EN(LINE(1),"1. Cactus <= Press Key 2");
	ILI9341_DispStringLine_EN(LINE(2),"2. Normal Plant <= Press Key 3");	
	while (1) {
		if( Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON  ) {
			Thres_T = 30;
			Thres_M = 3.0;
			pump_interval = 168; // pump every week
			break;
		}
		if( Key_Scan(KEY3_GPIO_PORT,KEY3_GPIO_PIN) == KEY_ON  ) {
			Thres_T = 25;
			Thres_M = 10.0;
			pump_interval = 24; // pump every day
			break;			
		}
	}
	
	/*-------------- main loop ---------------*/
	ILI9341_Clear(0,0,LCD_X_LENGTH,LCD_Y_LENGTH);
	while(1)
	{
		if (!send_photo_flag) {
			//printf("read data\n");
			Fetch_BH1750();
			//printf("read dht11\n");
			Fetch_DHT11();
			//printf("read soil\n");
			Fetch_Moisture();
		}
		//printf("mode selection\n");
		if (mode) {// mode != 0 display mode
			/*接收到新图像进行显示*/
			if( Ov7725_vsync == 2 )
			{
				frame_count++;
				FIFO_PREPARE;  			/*FIFO准备*/					
				ImagDisp(cam_mode.lcd_sx,
									cam_mode.lcd_sy,
									cam_mode.cam_width,
									cam_mode.cam_height);			/*采集并显示*/
				
				Ov7725_vsync = 0;			
				//LED1_TOGGLE;
				if (send_photo_flag) {
					Send_Photo();
					send_photo_flag = 0;
				}
			}
			/*Check for K2*/
			if( Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON  )
			{
				Save_Photo();				
//				static uint8_t name_count = 0;
//				char name[40];
//				
//				//用来设置截图名字，防止重复，实际应用中可以使用系统时间来命名。
//				name_count++; 
//				sprintf(name,"0:photo_%d.bmp",name_count);

//				LED_BLUE;
//				printf("\r\n正在截图...");
//				
//				/*截图必需设置好液晶显示方向和截图窗口*/
//				ILI9341_GramScan ( cam_mode.lcd_scan );			
//				
//				if(Screen_Shot(0,0,LCD_X_LENGTH,LCD_Y_LENGTH,name) == 0)
//				{
//					printf("\r\n截图成功！");
//					LED_GREEN;
//					Delay_ms(500);
//					LED_RGBOFF;
//				}
//				else
//				{
//					printf("\r\n截图失败！");
//					LED_RED;
//					Delay_ms(500);
//					LED_RGBOFF;
//				}
			}
			/*Check for K3*/
			if( Key_Scan(KEY3_GPIO_PORT,KEY3_GPIO_PIN) == KEY_ON  )
			{
				printf("key3\n");
				baw = (baw == 1) ? 0:1;
				cam_mode.effect = baw;		//switch between b&w and color display mode
				OV7725_Special_Effect(cam_mode.effect);
//					/*动态配置摄像头的模式，
//						有需要可以添加使用串口、用户界面下拉选择框等方式修改这些变量，
//						达到程序运行时更改摄像头模式的目的*/
//				
//					cam_mode.QVGA_VGA = 0,	//QVGA模式
//					cam_mode.cam_sx = 0,
//					cam_mode.cam_sy = 0,	

//					cam_mode.cam_width = 320,
//					cam_mode.cam_height = 240,

//					cam_mode.lcd_sx = 0,
//					cam_mode.lcd_sy = 0,
//					cam_mode.lcd_scan = 3, //LCD扫描模式，本横屏配置可用1、3、5、7模式

//					//以下可根据自己的需要调整，参数范围见结构体类型定义	
//					cam_mode.light_mode = 0,//自动光照模式
//					cam_mode.saturation = 0,	
//					cam_mode.brightness = 0,
//					cam_mode.contrast = 0,
//					cam_mode.effect = baw,		//黑白模式
//				
//				/*根据摄像头参数写入配置*/
//				OV7725_Special_Effect(cam_mode.effect);
//				/*光照模式*/
//				OV7725_Light_Mode(cam_mode.light_mode);
//				/*饱和度*/
//				OV7725_Color_Saturation(cam_mode.saturation);
//				/*光照度*/
//				OV7725_Brightness(cam_mode.brightness);
//				/*对比度*/
//				OV7725_Contrast(cam_mode.contrast);
//				/*特殊效果*/
//				OV7725_Special_Effect(cam_mode.effect);
//				
//				/*设置图像采样及模式大小*/
//				OV7725_Window_Set(cam_mode.cam_sx,
//																	cam_mode.cam_sy,
//																	cam_mode.cam_width,
//																	cam_mode.cam_height,
//																	cam_mode.QVGA_VGA);

//				/* 设置液晶扫描模式 */
//				ILI9341_GramScan( cam_mode.lcd_scan );
			}
		}
		else { // mode == 0 data mode
			char bh1750[30], dht11[40], moisture[30];
			
			/* display data */
			ILI9341_DispStringLine_EN(LINE(0),"Your Plant's Data:");
			sprintf(bh1750, "Luminance: %f lx", result_lx);
			ILI9341_DispStringLine_EN(LINE(4),bh1750);
			if (DHT11_Data.valid == SUCCESS) {
				sprintf(dht11, "humanity: %d.%d %%RH, temp: %d.%d", DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci);
				ILI9341_DispStringLine_EN(LINE(2),dht11);
			}
			else ILI9341_DispStringLine_EN(LINE(2), "DHT11 Error");
			sprintf(moisture, "Soil Moisture: %02.1f%%",moisture_final);
			ILI9341_DispStringLine_EN(LINE(6),moisture);
			
			/*检测按键*/
			if( Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) == KEY_ON  ) {
//				char WriteBuffer[80];
//				static uint8_t name_count = 0;
//				char name[40];
//				name_count++; 
//				sprintf(name,"0:data_%d.txt",name_count);
//				/* 打开文件，如果文件不存在则创建它 */
//				printf("\r\n****** 即将进行文件写入测试... ******\r\n");
//				LED_BLUE;
//				res_sd = f_open(&fnew, name, FA_CREATE_ALWAYS | FA_WRITE );
//				if ( res_sd == FR_OK )
//				{
//					printf("》打开/创建FatFs读写测试文件.txt文件成功，向文件写入数据。\r\n");
//					/* 将指定存储区内容写入到文件内 */
//					sprintf(WriteBuffer, "humanity: %d.%d %%RH, temp: %d.%d\r\nLuminance: %f lx\r\nSoil Moisture: %02.1f%%", \
//					DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci, result_lx, moisture_final);
//					res_sd=f_write(&fnew,WriteBuffer,sizeof(WriteBuffer),&fnum);
//					if(res_sd==FR_OK)
//					{
//						printf("》文件写入成功，写入字节数据：%d\n",fnum);
//						printf("》向文件写入的数据为：\r\n%s\r\n",WriteBuffer);
//						f_close(&fnew);
//						LED_GREEN;
//					}
//					else
//					{
//						printf("！！文件写入失败：(%d)\n",res_sd);
//						f_close(&fnew);
//						LED_RED;
//					}    
//					Delay_ms(500);
//					LED_RGBOFF;
//				}
//				else
//				{	
//					LED_RED;
//					printf("！！打开/创建文件失败。\r\n");
//				}
				Save_Data();
			}
			if( Key_Scan(KEY3_GPIO_PORT,KEY3_GPIO_PIN) == KEY_ON  ) {
				// force pump
				pump_t.hour = Hour;
				pump_t.minute = Minute;
				pump_t.second = Second;
				printf("force pump at %d:%d:%d\n", pump_t.hour, pump_t.minute, pump_t.second);
				Drive_Pump();
			}
		}
		
		// printf("%d h %d m %d s\n", Hour, Minute, Second);
		if (DHT11_Data.temp_int > Thres_T && moisture_final < Thres_M && Pump_Enable) { // satisfy pump condition && pump is enabled
			
			if ((pump_t.hour == 0 && pump_t.minute == 0 && pump_t.second == 0) || Hour >= pump_t.hour + pump_interval) { // first time pump || pump_interval period passed
				printf("pump at %d:%d:%d + 8h <= %d \n", pump_t.hour, pump_t.minute, pump_t.second, Hour);
				pump_t.hour = Hour;
				pump_t.minute = Minute;
				pump_t.second = Second;
				Drive_Pump();
			}
		}
		
		if(Task_Delay[0] == 0)  
		{			
			// not used: task[0] caculate fps
			//printf("\r\nframe_ate = %.2f fps\r\n",frame_count/10);
			frame_count = 0;
			Task_Delay[0] = 10000;
		}
		
		if (Task_Delay[1] == 0) {
			// task[1] send data to server per 10 sec
			char cStr[15361];
			Delay_ms(100);
			//ESP8266_Cmd("AT+CIPSTATUS\r\n", "OK", 0, 500);
			sprintf(cStr, "{\"Humanity\": %d.%d, \"Temp\": %d.%d, \"Luminance\": %f, \"Soil_Mois\": %02.1f}", \
					DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci, result_lx, moisture_final);
			//sprintf(cStr, "313C4D2C6C5CDE59951CF937A04E09CF2B7A6D8282FF0BC3CED878E2D673BE51949EBFEEDCBAFCE585F8434863C775B4A24C1BF1433D8258D79807949F4DBDF1B81EDE42B286EE2C595A80DDD35B545E94507B18D210F574E5D5A5A9694170564603E471DDAF44E549A5115262AD593ABEEF01019AB45CD47FD0F6E3D7DD7F1C6A4C050EE5B7F7F0CD07946C930E4884E4E036742CBD9E73279FC890042D519D0BDAE1BE7A0773FBD228A4838DD274F2CC4DC40BC24F09754298C301F661699745CDF32841EC538728B640B9E8D386F49B372C12B7E488289B463E57AA798A647A683890DC7289CA37DD88394BE14D4F195345180448FCC726A7539CE695E7AFA82E07D9B8E7061044C70334C4461906FDE30348F7B62DFBCEECAF7A375D6EE72E7D7048BAE6F98CD12EFF870046F846ED65248F7D602F7FF90D921DBD949F781A82EE5253068A734D39DCE279E6B932619F8B5A11AE452476C2E482EE7CAF1A8B5A7A77312AFD3A08896B0FA8AC3338BD80BCA37730A419BA7A1DAD87FDDF0C43135FC3CEFC3C2183B3E74B4B3FCAEC134CED9BBFD3AF22CC71D6FCB2498650F2B220CFF97D687230B556AE022224F26296368661AF00622D4FA406F438C6EA16B0CCBE1C7DA678EC3D5D6D62294C18E25117BA669FC0CFB61BE727B3955807BBA08D44F61C50FDE6D1E2A09857F39F8EE06FB06C79CB1D246DF66190963F0F0A6C9299BE7B145ED5F621B4A134636924AA738B2109F63E806E2D715A4832A4FCB269DFE59E330870B6DE118DE0ADAC9598F0C1E76CFB0CD69E846AFE74952394EFACCFB4F1388F66376D558892A7C0D94865FFA483AF2C404EBE5D51991D3A04C5CC4AF84EC15F1874A220030E1B3D9D272A734E439EF22F1746CC1F01D164E42314A2BC0F8291D544BA0E7395858126D6DDE9E4FD27AAF8213B2D2AA10DD049EC05EF924D549FE46A7427FCF0E0BBABBB5317F2BBE72D1F27E514B72C78AE3D546605AA35F30AA8BCF1FCE5EC7F1947B4009C63BF649E15270F8F4818BD877EAA8A8E4F5E4236C56EE99C781051481DC1F12B1160FDFF69C6968DAB9FBE11C547EFE61E91910C6B69A9D7931B90693F02A29DA92840945E04067941CE190E5C1DFDE810CE9C1E8E21E850EFCDD4F91F3D242DCB10F237864AE21E7C03489B3746D78EFB5DE1B706E886D873D65AA7DB52F51188EFE6ACAD42C539022BF5D6943B95AA6CB6B928FA37F0BA2D5580BE0EBF88517DF42D93FD6288E32B111129266B1B0F01F6430B583855D652485AD79F98093F5EE458E811B529570E834A17EAE7E9AB5B0A30EFE8DE4D6FAB364610AB489EDA58ADE2EAB27FE3D32F3E7AB3BD91811823EA63B160FC8FEFA3708B3135FE71EC44873056CA0B4F684DF833F6998AE010253685D0802B97A21B38BFC7AE329BB71B85321964F7B32F8A220EA431E5790D3FE49AB8812E96AF3FF23945022DF1D20AAC400E54EAA96ECA08248F5A55C837AB5BF62F01C1797D58BC6B9B1D49361D92CB042828D1EA6FE08DC33B51C2C8069E333A29CDE2A956DF67FE18A1EEECEA49672B2D90522767424A303E42D5B7AD4F683F1504D16AC8F74B5A9D005259B9724C0B66578EAC0D55E45DBAFB92F8E66F5BE74E1E2BF50B305D23515B405EC118633B265B50D29D978AB94FA0C2F75A97322C7298E8E7ABFC46EF5A3B4F80FE40D2F9BE8AEEADC9C791AB36036DD4EEC8B4261939E3CF83F1CED3E964798392D7AB8C48238F67F04C527904C5223074ABA5465D93AFFB3F014BE3B30D72AFD000683A1CC1711D673ED6ED00F75005E735680EE829F3992C3C0DD769F07C935F3D5F6C5E2B384DE47C859D9C53E5A4A5A1F35EE7C04F26ED6D99070A697F030640AD5E7B6C56DF571F8A89E66D503824D2A637C582C4D4858CA1C0BA75AF77C9A3D0EBC64F314493C05D3E14C4722A0DAC4C9610D3A546C2F2519AFD081764FF360C0786E7B08CA1BE45B1270C673D8C0F4B81D081E048A74178DBB2811141C3CC7B359C6FFA06038A390009672A0FE2737DE84B7150555F4EEA50CD3D4BDB2165DA7340C209C2724149AF6C95B892D6312C0D7007119A4CCDE3BB02BEFB677A1A6EC401BADDFBAEDD49BEE3D0CC69F05F68EA126F1AF8FA1B93DB06C6ABB276290EDC010CA4A70973E6B9B0E7D805ACE2A5F7886FED48675AB3D240EAE11E6838E36BDC9E1AF43947935AE95F2D844522839C2437A5C229D094287A148D6D5405D26BFB340F74F529E22BB79C608F47CDB09F99A4DBCE9186418D970D2B6B67DF88AC6F873619B5D2C1D2668FC6FF223FE08D11F35C5293522183CC6B3180108F48CAD0D9909A6065A396400E808AFDDDCBCC0E3513EDE00A0189C4926411833666075206B4D8DC60E9BB094ACC5065B175A8CBBBF609420E21407FF4969C99FFC8859B73865103A22C2164C92E9ED4236A5B29ED7B5E96F32C7A9DCA8F75A1D78620B7DE5C4AFA3ACB820C0440E4CEA1F15442DED8C82B55D26DBA1A1862F8777EDB9AB4146510D8453FE946EB02C46F987FE1229508C1CFC6805DC98E0EF3C27674D5C2604ECFB8D2EBC18F59F2DB64EA1720CE157BEDF292BACF019070EF67BB6DEE84E0200E3251FC65358F9DD7BAB0885C609F123D8E0CBBE1F5029EE660A97F79602199A2FD21ED82062C60C9DABE3EB4A0F850722D721ADC0A967933E55A5BC13CFA469E3D77B95FED14DC4EB20E77F8C59109049D9A572358EB12847AD9E2E1B9E6A32554A28741B5CC6CCECA541C393047A4A9C3AA563FDCB326DA64D7FE49305E7CAC34C18F30102A05DC31D832442D0A2B36BE0A92AFFE3431261A6BFCD5A522B21D38AD2B94EADC67C648933C81C5EA7422CD8B20BC3217648BB839AFF511CCC34621C5B7804462805BD9613D0D78B8C81A72903C416E6522AF142BF2509045DCF57CD9641C3067487E376F4EBFC347BE0A8033B49922A8BFA3F1E687C56067DAC90E20B5315A5669D0F71991F54D3CB14B4A6667338270CCBA47B3862C56C3034DF52682FC797C0747A44CFEBD1259F8CFB0F70EFFE68A87254B3E979695EA6F3E9AEB203A0FABF7492C08DB26C7C99742F84720478BE094AB11C87C1AAA615BA442B674B032E1F2D278E5CBBC2931569EBA2BCCAC221149CD9AB5CE3ED11165DBC72A1E235D895C67967280D2B00C475415AB46F9D086D13678B4AECD8F3086A3C258C454A0C4E7405D2DAE594555F660EB26DC1631E96340026670126CF44871E3A8882C08515F48B78F768C68D5C3AC3413DC707EACD26CFC54F563F0C562A914CAC007B35A6299D62A60A84CE0F37E838A039B1DBF60C89DC341CE4327BF5F2DA719DA129E122A913DD78DE29F042BC068BCD61FE6609A396830C3FA0B492AFAC9774C80A8813CE44FF36A75A132328F8DC6DB3BDB12AF66125E6895293921BF60253C16F4E0722BB8F05AB74AD23B4609AF49FE0C5ABC12C7069CA3223EFDEF84B7FD4E1446F6B80C933A3FDE8D361D6567A1982D9D75AD7E61274143265AF9C99D665050D39C8795A1A181B395095DE26CB26B484712B475E4AFD582D1957040C2395E463FD5907F42D2107231488007590AA7405AB94A33CFDF3E034C66D15B12ED509174144E751F055A1BFCCF10EEB8EBCBD1E4E1331192921AF3973353BAECE868B74F5738F5D3E8BCA6477BE46E08B5615992FBA65CC6DFCD098A401A8046F369D2B60A8A48B25C90FECCF3BAB22C3C681EF593FD56F1743D08C4CECE3A2119F915FA635A05377595B688212439BD82DA6CED88F972B563DCDF585CEDE804EF8546DD064248B710A9CA313F6E42D4E33C79C1AAE9294493DE836E7439C46C1B42EB30B562885301BE2666329336A2FECB1EB03AFB1FDB5864F86D63EF401E296941729B1C43D9A05BE8130D5D25558DA9663416157FE4C99A26EA23C2646F441ED08A4616A30316AAD39EE85666EB0F186AED465EB811B4B4AB0692B2CCB8C3556A2F8FE0746677C791D1C09D5F7C04BAD5620C55DE9C6AD1B47E55C6462FFA94C98FD44D8F7CC81A6B85D04583564FE3ED1D1C091BDF85DFEF7751B656365DD10FDF4E093FDA2D5F5CFEED39D24125705252D19B7EA10006F7271F7F4E5CDF9CC3F81A45A7160843276E30B3DF61DDE0794600773C760B8E787903CD35255E789973DE9AFB03A770A30382B23C6662EA97515B4CA363710C4641D6CE667CE7FD099B7B5DBC104BB95E328BC235F3BCE070878A18E463F4D0DD6697D7C85D99F086C336BE7AEEA7545063EE8156AB872EFCCC85C0E962ACF238A68682377FFD503BC75CCD6EE1CE19F1178A59BF00616B65A02EB497B38D574DBD9F55725F7F8326080ACB72628660C7DA221047DD7B3887CC1AEA4855D9356B8A3A187844F70D09A651AA15C0AB18A5D036E91079895F55F8D474F566959AA282A8AE281022EB3F4737FD5E403658BF4545B60A3621419E1F5551173F1E14455A6D3EF3BF0BA4CD248E23552EF8B0ABA3A08A056818282781A6E27335A69F272B35C905747D98780ADE0307555B8D8F3583B3E221D03B694FA807EFBCA9D01C5F18939BB009EA374E1D0FC78E00617A72D6A995EDF9B087BC57BDE42AE4E543B2A8B2FFA72491932BBDBBC6E2CBC9AD49E89CEA44D2ED95854A607351DA268A95452C15908A10403B88B196535B73C0796242FE10883C327F40EE59C339033439316C52456721851E6CAE8616EFD699006CF59B41364EF74446440672C45F80B68BE8AFF5AFCD737F74DA6357A2C14E80ECE4C95FA59B496B02E30D46026AA530A35F06A3F60E0DC8148435DACB940D6DC802A97971D1C6AB47D21F93E20BEE30090945785B3D422BA97EDAF2ABC837C078C6510DCC5AA268AACA110FAE3A22FE270D5E1F0A85AD43792A5044B6E9C7CC2D8729B272178DB8862BA3E3DEF676F811870792FF3B4AB7B3AC7DFCE618CEA4E3691B7A7B0F3332024B6EA5A8FD831254E746CB9FDFC1756DA984661615C2C1222EA333048C080600F69BDD236F269F67D4EDE81E3D7D17D911457A4191A4F2E39DC95148EBDF38B7C9EBFC02DE27D137E3C62F36D0A5C6F333FDF7003B8FF211E41FAFB608CB008714E00A83856BEE77C955F6E0E4612FAF687CE69973ECAC3B20BB1BCD9776FF12D57AE18190B0E6B3C6C530F4457DB4901E66A5E5C35DD81987B1242B99CC9ADB188C36B30A171A31AE6D0A4B48D02F5DE24CF2AD1B3FF18CFA4AA409257203422237968F5FB4A2A3CD4087D4DDC7154557F01E32DA25A53408D135ED8F701AD87AAF8BD3951ED582EDA0548915895EEB59FAA797C0FEF614C90996563E29E38DE8479937F1844398298A831B741E2826E451D1FD4BAB7BA80DF94F6849AEA0FC39A4728FC9DA9998E8C1EACC6DC3512EE2E582604C2ADD0766869E0A201E9626B313890B09862FFB66D2539A08B7526CA0B82E147EA39A7AB5F0A7116D027FF20BDC80B0D5615999106F398968009FD3F1AE1882FC14E8259984555CFBEA25993BA87FD8157E4FF005A477E041331B4A393F74CC649092B98F442EC2B37F8950C4C6C3A06C1E27EB83DC62376BF4E3E836D05284D1258060317C201CA2001E49661B3C5683F6AFBF3519DB69CC18309CFE409DF18BBB11545FA87A92BBD9D6610DB8349CADA16C64653E0F33B65408999D9921444C7AF94D2BDE75CBA3204E3FFC6B009BDDC7BACF8D8BF0F9AF0290258CDD3B3A0DB41D500CB953834057A8A6916B08A22D01FBB9BF7D67886F4686858EBDCDC08D88456922CB134D02D78E21B9242E1000C31E2CB970D02744F9ABCD78AD98C9C7E4CDA6AA8141D960E17CCF7FEDBDF7679ED73DEA8C5EF2B1528130C57D48B558EF4EE101CF078760E901AE401969F44E1DAE1EAE65D3B2DEC191AD214F25D40D39109BD85A92B3D4EB9383D00815BF1075DC10837797BD16871958F27F6F8E269082B8AE39B529EAA3766234A45679AC61CDA97D2A557520F866E00790445CDF77C0909E9F15A5C99B72A15CD4EA2AB909D22FD1909A6C055C8BBCFDAFF99C245E642EC918C467BC56CEEE3378D53B43DF285680646C8849390C861CD0BB4ADC07379D67D67F459F08397E8FE2ABB987ECE9FF14DAC1EC54B9661C842CEDFC8089D1FA5A4E8ACA67F0633859BB21E9B31EE2E571F2D2BF78FA966E889758582310E4A37C59E4EDC463BD85D07CF7822CA0AE93921A21C7136A2CB2CFC58D9B7B212016B3B301315C08DA8A9D15AEFC2C12FA445935F37F468DF620675CE2A0D74934E3839B4DC0CC97F0DDF741388E6F2333965485D969E84EFF937E1BAA7EDC7346AA8A635909C9B6C4A717B7B4C159CAA2323334F87CA42C4768AFF7FAA20C1F735D01A10C3D1A8712A9367437064634447DCC2B25E9B937DC3DE49120D2A5DB0BC6F9F47087D444CF0CA384E1107F9A3C2CBC207BAFF9FE0D46B342C5573BDC0F2EEC9B98C175EF7D597F38C58B9891F00E15140F463403C1E02849733FD22CCBACBF9087597EF2A314CECF5F5EBF9685032B38A0E44AAD4FF8193B60998F7EF41C5C105430DE38811DE0962802F325C0759C810EBBF50B14D021F8AD72A0EBC2505DD592F1C6D8DFA2AB7BC4C1B9BFC4309D9C6364DCA0B8330040433EB94560242D837CAFA92E6ECF22E16A571ACA51F894EAA8F6C7B180F15B90E474F8F43268017C6E31295B863D08513E9763A2C466B05E6C35FA4E5BDEB67E475F53A4BDF0BA04420602737B47845E608A317BEE86EEA051EA3F70C10294569989DF8BB74CB0E1EC46A4CE34849BF1DE8A9615328FF44D18AA6C85CA14A523D5B4EE33016D9376F7BE5F26E1E753597D506F160AD83F37BE491961AF4D1B81D3EF9D06E07D6A980D82A0E504BA896ECBC08B0A6983DF33CFB84567BE2EA7A00D16DEC6A404DD5823B961462DCFC71C097E98C11562D727A547AE17FED555168203757D279E7791E152366F7A09F20D73C175105D00BE6AEB2F61DF63F3F35EF91854AE7F85DA8DCEF0ED14064C0328EA07CD11A971F6F8755965F72374FEFA7B19566AD372B4D5442EFFC32AD1E40726F7B8C95D07C80B83812F69423CC1114B14F2F59F1EFE0E3AF40F296BA995EBE04BF63DBD4D8DE95C355A7835D5AB6E335CAA73C6BE5F0AC01A45E960196B0FA96EA140A2E3AC8E0A57239064A036520478F0C0336F3C412EA01E243D744CD276D66D18858AEA291C1A565F8B935105B27F716E75219E43865EC1212F3D3952DFE2C582D98F326B3C48F0E3656DC499403C067EED607EC56C6D57B4930DD2EEDA42F821522D6E2428A24334B1274060DCCCC28998CA03825F7A7F397605D9BDF678BE6497EA0E751A346DCE11D8FDE5BBD3E8905FCB2F084849F11DFEBC32120FFC517D070786E6E1942B26D082F2092E457D9B92C0988B959F5039E5A4D0F7A5ED4630B97AB40D4501F79CBDC0DFEA99B346D48BBAE8029802371409A1516C449E116D9BD26028E40813790F8FA1287A4ABFF828C8BB2F6C7798049954751B3ABF1400C3886F1442F47623A40E06D2CD6B03EA2F5A3B99E743E2A63E0B628960AB4A238807485BD06153358A327550093930403009EC033BABABC862A381A8C53F3EBB0F3ABA380B98C305A8BE49F799F51EF7FB95CB8CF6695D5C9AF2AB77FE69C36E4D3496F518FC3906293A3EA4B61D944486248727A327419F3B09FBE8399D04CFD797C57A15101CC0522E9E5F143585879958685E250BB9760A51B007E2F7F592B6D44EF61D196D64AD19C8FECCFF0DAD2A08134D559782CD517042C0C626A6721F73116D76C7A71CF62D07E3D8E7109F7C7E952B6C0A30FC58D752931B987617A55379FE37E74FD1174D90EB2B05334E60A156250848DDFC1D00EF4C718800233E7C8D3D6BE5F9CEC9EE37D808A9E7BCF55B4C07BEA3CC117B72E2C5BCDD7E9B858E23ABF671316566E517E788EBB326B346971B25DA791A399D8A0C9F70656F4FF131E3CC4635D42D8C967050382B1572F3B4C3E82AFAB9F3E16B73A645C5F59FC8F67A1C231180D4B69FAF0A7FD6017CAFF16349261BD3647702D3CA061F6C3A7D5B5B24A4C3425996079F7A917C7D86769A0FE5692E38E4A56229F1ED42524C182DC8B98485FF5AC29EAFEE4528502D28BAA6F4DD6DA8297759688439C447DAA1A78B83559A5B752FDC7BB1244179C57F3D2889076D434D637E403CDD6DEC6300DE6F0CFC1C55D005E69D5C4C161B1083890A0FEF66FF44DE97429B62AA75A7C6AF4426549DE11A75DF62020FA224AEFA74D46991AFADE9CAAD5258616F91C4DB4BE3EF3D2CA55F118D3825CF157FBB8F9C63403DBFD21ADA2F13D474A52B7A7025C941D7F58394B9485F0416E267C062A92B28A88254DF489C6640E445201252A52E6C9E970DC23A5B62F548338C0A3A6C29D62826768CF3841F952C488063882409AAAA924F95D5503062DD7A64AD55BFF1E24728F564BDAEE6CE48DA8E7230F9658B63B3373203B3E87C236E61C73489F2CE32C024BFC40F531BBA004AB16943F8E31C6112183312EABDFEAD15C329BB6E1AAD155D84BC4CDFE1C84426716F63B467BB8AD8A6210D4972DF50AD19CDE770E3DE29D289AF6FBA1A386097F9895DD349383187CB563FCE4888472EC4C0496E9967A010878F9E6C45F2ED941025E5BEB72891FCD8E2D712A4AA99E5C6D192B4941E35A92F0FF0A746450496DCED648A44E724BD7325F70F36E880C5A347C58CB8ACCED6A903B1686CEE5192EF4A0090A24F1540B6316C711AB115428EE7978ED2D0351A170722188F52D24EE77914CB35C4BE3FDAFBD4D4563268D552E572BFC944114E043143E1226E8DB8CAEFB7D97F6804EEE6E59A2CD1CF5F8BB148D96AB7349C78DC3923BA1BDEBA83534DAFA8C75475AA9D513A30EE6E6321CBD77387CE03CD969B98D754482582BEC3AA8EB1A591510B0FF2AFB771D330563F269DA589F8B4E75BF681F71C549210BC7075E9E946EACC8A04E991E8637EA28DBD477D6A7DDEC61BC428655901225CB7ACC47DA8DC5B627403DE521BACA3E94AD14293FE45A4552AA119816470F7679EA531473E119BCCD05A9F74AA8F4E11DB958AB14863EE0EA11690C52EE4FEC6D95B756E86264C79B44943BEB473E208243FC4B24FA547BB74392952A5921884EAF937AB1E5F4966F73D3D046ACC0BAD3F3D6D51CCFF623344E2EAD2458C191A68509672B6E82567EC896CBBAB246ABD19FABF16D052ABC9C013E7DAF884ACDF6E4B4ACA3122D95AD6DA1AEBB383999FC9362ECB673D480D91548B801345B9602D958B7F2AB2B77CD4B58BD4C24FE733986A68050823D214E3D0C56F93D33A0140085CE2FBA24757FA28E487C6A6F4DD9146FDC661CDCA9D5538B031468F1664AA92743E7963AE83F008EE59FBB2F46E250081AC1C2482729F603A12F232101857F3D2C7C140E7DC4ECD91D591BB5431D25DAD18FF8C0627248616D6CF17F9FF7EB43CE9AFBF294308AA64CF70F89393487DF206E5D97999188D36C1202C966DD27970A792E9E3F617713BAC45F319D1A9A06DC76ECBC303474AD26929251C105619E2A38C5AA7A2B7D515BC4B20CA2900926341A3D9DF42686CEBD2045E577A38837E8FAC83E20057CEB391A834A3B1107B52EC336AECF8E6A8CC896F0235862D68D8C2CAED58644EF4CBBFE75EDC407F65D13A74D12C2FD5CD060F64C9F0C2C7DEF2E472202FE2E3C4C4F8ABA866E0B3D4734DAA849F27B949B0CAAC4180CD8AC9E3E832B998D3C1A4D6CD9F5F07BA5164A4D3F37314956E8504DBEE41C0BEE31726020F64D8F19CA87A05361CBA77AAE250962BE3A8E728F225EEE5628AFE05A401C7D3FA62E3F8910A95BC9DCE7C13D04D6D7592DC722DDB7A95ECDAC8BFE6CAE3E918ECB293B7D8C207BBE9126F6E68CC43E7F38BDFDBCBDE60CB2A355C352FDA8708135A4D1EF8B0AEB6315BC93CB739F44935E8A04FB765E3AC73F501DC23EDC10C3539F53DA3582777D199417AB5B56E903A3C13FC6D804F69293C72B5CB092655C680B75B28E1D71A55E9DDBD8293AE8BF5A761F8D1F2DB11DE472DF7FF292C72D3DE2FDA18217EA75B5D3F5D4347612C6C86AFE602B452B23242185E0D6682D8EDE64ED631EDF7076209A5D6D095B34B76A0C452EA8E0E3193F0D7BAF1AC7D05E77C3152AE3235DDB01F3C51304973668CB187879270E9AFEA95A1830956A244FC45C7D710B71F0D56AE033ACDF662B9EC7603A09083FF9A550468B6B9C086C63456151028B31AFA03F28B3DB79896E4669496854ABC22754F7C38DA2C03680F0E44CFF6E2479C000DEF39F609E6D340874785B1EDBA78C677F6C81BCAB351C584783A5D177B80E3B7F6479DFFBA948562E7B024F7C89AD6E7AD51018FD7C8CE6F03785BAA9A135F016BFC103BF24F6425AB91005AFD6134C478AD9AACF03BBCCEE507BB3D41C6A31872797AFBD62DA09F3A9E5255D37BB4829AF27C69B4F53B5B7EA907B16BC8D6538E85EC0E64FDD75C7E149E01093D5BD3AF0A0C68AA209A7BA073E7CF788C378ED34B792130550B65765EF4F64D01A2E5F43BD3E18B48401F68D3EE1ADF5DD70CD84C05A86A4EA5D7DD67CA08419BAEC0478DE9EC37CA4BC0169C6A5174384A2F8AB67327CED583B362154A20EAA5EB20A412F19F90E5386AE976B2268BA96455D806C061D25D6743C0A7A22E0541214222EF291A4457F31292B49A340CA7DD30EDBF50A001431B5AA0FEA9B61E358680A17C250CC37CE70C2614B1F4258F610811F8C64EDAF2082016CF4CDBA5A6AB99DF35088F835A24BC74A01D367F3CF328AC439A43821B4AE57D3A6F302429D22FC170E65B48F1A7765548863D0468C4FCCA19FFA76E5E52276E1C2C75BF4A90D9EDC9B61E8C738A22D");
			printf ( "Send:%s\n", cStr );
			//ESP8266_Cmd("AT+CIPSTATUS\r\n", "OK", 0, 200);
			ESP8266_SendString ( ENABLE, cStr, 0, Single_ID_0 );  
			Task_Delay[1] = 1000000;
		}
		
		if (Task_Delay[2] == 0) {
			if ( strEsp8266_Fram_Record .InfBit .FramFinishFlag ) {
				// task[2] listen to new command
				char* pStr = 0, * qStr = 0;
				USART_ITConfig ( macESP8266_USARTx, USART_IT_RXNE, DISABLE ); //禁用串口接收中断
				strEsp8266_Fram_Record .Data_RX_BUF [ strEsp8266_Fram_Record .InfBit .FramLength ]  = '\0';
				pStr = strstr(strEsp8266_Fram_Record .Data_RX_BUF, "water");
				qStr = strstr(strEsp8266_Fram_Record .Data_RX_BUF, "photo");
				printf("Receive:%s\n",strEsp8266_Fram_Record .Data_RX_BUF);
				//printf("water\n");
				strEsp8266_Fram_Record .InfBit .FramLength = 0;
				strEsp8266_Fram_Record .InfBit .FramFinishFlag = 0;	
				USART_ITConfig ( macESP8266_USARTx, USART_IT_RXNE, ENABLE ); //使能串口接收中断
				if (pStr) Drive_Pump();
				else if (qStr) {
					mode = 1;
					send_photo_flag = 1;
//					char output[DLEN*2];
//					unsigned char line[DLEN];
//					uint16_t read_data; // 16 bit RGB565
//					int times = 153600 / DLEN; // total times for sending data
//					int pRow = LCD_Y_LENGTH / times; // each time's data contains how many row
//					unsigned int i, j, k;
//					printf("start sending photo\n");
//					ESP8266_SendString ( ENABLE, "bmpstart", 0, Single_ID_0 );
//					Delay_ms(200);
//					for (k = 0; k < times; ++k) {
//						for (i = pRow*k; i < pRow*(k+1); ++i) {
//							for (j = 0; j < LCD_X_LENGTH; ++j) {
//								int id = j + (i - pRow*k)*LCD_X_LENGTH;
//								read_data = ILI9341_GetPointPixel ( j, LCD_Y_LENGTH - 1 - i );
//								line[2*id] = (read_data >> 8)&0x00ff; // RRRRRGGG
//								line[2*id+1] = (read_data) & 0x00ff; // GGGRRRRR
//							}
//						}
//						//line[15360] = '\0';
//						base64_encode(line, output, DLEN);
//						printf ( "Send:%s\n", output );
//						ESP8266_SendString ( ENABLE, output, 0, Single_ID_0 );
//						Delay_ms(1500);
//					}
//					Delay_ms(500);
//					ESP8266_SendString ( ENABLE, "bmpend", 0, Single_ID_0 );
				}
			}
			Task_Delay[2] = 500000;
		}
		
		if (Task_Delay[3] == 0) {
			// task[3] save data to sd card per minute
			Save_Data();
			Task_Delay[3] = 6000000;
		}
		
		if ( ucTcpClosedFlag )                                             //检测是否失去连接
		{
			ESP8266_Reconnect();
//			uint8_t ucStatus;
//			ESP8266_ExitUnvarnishSend ();                                    //退出透传模式
//			
//			do ucStatus = ESP8266_Get_LinkStatus ();                         //获取连接状态
//			while ( ! ucStatus );
//			
//			if ( ucStatus == 4 || ucStatus == 5)                                             //确认失去连接后重连
//			{
//				printf ( "\r\n正在重连热点和服务器 ......\r\n" );
//				
//				while ( ! ESP8266_JoinAP ( macUser_ESP8266_ApSsid, macUser_ESP8266_ApPwd ) );
//				
//				while ( !	ESP8266_Link_Server ( enumTCP, macUser_ESP8266_TcpServer_IP, macUser_ESP8266_TcpServer_Port, Single_ID_0 ) );
//				
//				printf ( "\r\n重连热点和服务器成功\r\n" );

//			}
//			
//			while ( ! ESP8266_UnvarnishSend () );		
		}
	}
}

void Fetch_DHT11(void) {
//	char dht11[80];
//	Read_DHT11(&DHT11_Data);
	if( Read_DHT11(&DHT11_Data)==ERROR) printf("Read DHT11 ERROR!\r\n");
//		{
//			printf("\r\n读取DHT11成功!\r\n\r\n湿度为%d.%d ％RH ，温度为 %d.%d℃ \r\n",\
//			DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci);
//			//printf("\r\n 湿度:%d,温度:%d \r\n" ,DHT11_Data.humi_int,DHT11_Data.temp_int);
//			sprintf(dht11, "humanity: %d.%d %%RH, temp: %d.%d", DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci);
//			ILI9341_DispStringLine_EN(LINE(2),dht11);
//		}
//	else
//		{
//			printf("Read DHT11 ERROR!\r\n");
//			
//			ILI9341_DispStringLine_EN(LINE(2),"error");
//		}
}

void Fetch_BH1750(void) {

	Start_BH1750();
	Delay_ms(180);
	Read_BH1750();
	Convert_BH1750();
	Delay_ms(1000);

}

void ADC_INIT(void) {
	/* d.	Configure ADC Clock, please refer to the tutorial notes.												*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1|RCC_APB2Periph_GPIOC,ENABLE);

	/* a.	Configure the PC.4 as analogue input (Refer to Tutorial 5)											*/
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
	
	// c.	Configure ADC1 to get input from PC.4 																					
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfChannel = 1;
	ADC_Init(ADC1, &ADC_InitStructure);
	
	/* e.	Connect Channel 14 to ADC1 and enable ADC1, please refer to the tutorial notes. */
	ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);
	ADC_Cmd(ADC1, ENABLE);

	/* f.	Do a self-calibration on ADC1, please refer to the tutorial notes. 							*/
	/* Enable ADC1 reset calibration register */
	ADC_ResetCalibration(ADC1);
	/* Check the end of ADC1 reset calibration register */
	while(ADC_GetResetCalibrationStatus(ADC1));
	/* Start ADC1 calibration */
	ADC_StartCalibration(ADC1);
	/* Check the end of ADC1 calibration */
	while(ADC_GetCalibrationStatus(ADC1));
}

void Fetch_Moisture(void) {
//	char moisture[80];
	uint16_t data[3] = {0};
	unsigned int i = 0;
	for (i = 0; i < 3; ++i) {
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
		Delay_us(10000);
		data[i] = ADC_GetConversionValue(ADC1);
	}
	moisture_final = (1 - (data[0] + data[1] + data[2])/3.0/0x0FFF) * 100;
	// printf("%d %d %d %f\n",data[0],data[1],data[2],final);

}

void Pump_GPIO_INIT(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	GPIOA->BRR = GPIO_Pin_12;
}

void EXTI_CONFIG (void)
{
	EXTI_InitTypeDef EXTI_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	GPIO_EXTILineConfig(RCC_APB2Periph_GPIOA, GPIO_Pin_0);
	EXTI_InitStructure.EXTI_Line = EXTI_Line0;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_Init(&EXTI_InitStructure);
	
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}

void Drive_Pump(void) {
	//uint8_t ucStatus;
	GPIOA->BSRR = GPIO_Pin_12;
	Delay_ms(2000);
	GPIOA->BRR = GPIO_Pin_12;
	Delay_ms(200);
	
	ESP8266_Reconnect();
//	do ucStatus = ESP8266_Get_LinkStatus ();                         //获取连接状态
//	while ( ! ucStatus );
//	
//	if ( ucStatus == 4 || ucStatus == 5)                                             //确认失去连接后重连
//	{
//		printf ( "\r\n正在重连热点和服务器 ......\r\n" );
//		
//		while ( ! ESP8266_JoinAP ( macUser_ESP8266_ApSsid, macUser_ESP8266_ApPwd ) );
//		
//		while ( !	ESP8266_Link_Server ( enumTCP, macUser_ESP8266_TcpServer_IP, macUser_ESP8266_TcpServer_Port, Single_ID_0 ) );
//		
//		printf ( "\r\n重连热点和服务器成功\r\n" );

//	}
//	
//	while ( ! ESP8266_UnvarnishSend () );		
}

void Save_Photo(void) {
	static uint8_t name_count = 0;
	char name[40];
	
	//用来设置截图名字，防止重复，实际应用中可以使用系统时间来命名。
	name_count++; 
	sprintf(name,"0:photo_%d.bmp",name_count);

	LED_BLUE;
	printf("\r\n正在截图...");
	
	/*截图必需设置好液晶显示方向和截图窗口*/
	ILI9341_GramScan ( cam_mode.lcd_scan );			
	
	if(Screen_Shot(0,0,LCD_X_LENGTH,LCD_Y_LENGTH,name) == 0)
	{
		printf("\r\n截图成功！");
		LED_GREEN;
		Delay_ms(500);
		LED_RGBOFF;
	}
	else
	{
		printf("\r\n截图失败！");
		LED_RED;
		Delay_ms(500);
		LED_RGBOFF;
	}
}

void Save_Data(void) {
	char WriteBuffer[80];
	static uint8_t name_count = 0;
	char name[40];
	name_count++; 
	sprintf(name,"0:data_%d.txt",name_count);
	/* 打开文件，如果文件不存在则创建它 */
	printf("\r\n****** 即将进行文件写入... ******\r\n");
	LED_BLUE;
	res_sd = f_open(&fnew, name, FA_CREATE_ALWAYS | FA_WRITE );
	if ( res_sd == FR_OK )
	{
		printf("》打开/创建FatFs读写测试文件.txt文件成功，向文件写入数据。\r\n");
		/* 将指定存储区内容写入到文件内 */
		sprintf(WriteBuffer, "humanity: %d.%d %%RH, temp: %d.%d\r\nLuminance: %f lx\r\nSoil Moisture: %02.1f%%", \
		DHT11_Data.humi_int,DHT11_Data.humi_deci,DHT11_Data.temp_int,DHT11_Data.temp_deci, result_lx, moisture_final);
		res_sd=f_write(&fnew,WriteBuffer,sizeof(WriteBuffer),&fnum);
		if(res_sd==FR_OK)
		{
			printf("》文件写入成功，写入字节数据：%d\n",fnum);
			printf("》向文件写入的数据为：\r\n%s\r\n",WriteBuffer);
			f_close(&fnew);
			LED_GREEN;
		}
		else
		{
			printf("！！文件写入失败：(%d)\n",res_sd);
			f_close(&fnew);
			LED_RED;
		}    
		Delay_ms(500);
		LED_RGBOFF;
	}
	else
	{	
		LED_RED;
		printf("！！打开/创建文件失败。\r\n");
	}
}


void Send_Photo(void) {
	char output[DLEN*2];
	unsigned char line[DLEN];
	uint16_t read_data; // 16 bit RGB565
	int times = 153600 / DLEN; // total times for sending data
	int pRow = LCD_Y_LENGTH / times; // each time's data contains how many row
	unsigned int i, j, k;
	printf("start sending photo\n");
	ESP8266_SendString ( ENABLE, "bmpstart", 0, Single_ID_0 );
	Delay_ms(200);
	for (k = 0; k < times; ++k) {
		for (i = pRow*k; i < pRow*(k+1); ++i) {
			for (j = 0; j < LCD_X_LENGTH; ++j) {
				int id = j + (i - pRow*k)*LCD_X_LENGTH;
				read_data = ILI9341_GetPointPixel ( j, LCD_Y_LENGTH - 1 - i );
				line[2*id] = (read_data >> 8)&0x00ff; // RRRRRGGG
				line[2*id+1] = (read_data) & 0x00ff; // GGGRRRRR
			}
		}
		//line[15360] = '\0';
		base64_encode(line, output, DLEN);
		printf ( "Send: [length = %d]%s\n", strlen(output),output );
		ESP8266_SendString ( ENABLE, output, 0, Single_ID_0 );
		Delay_ms(600);
	}
	Delay_ms(500);
	ESP8266_SendString ( ENABLE, "bmpend", 0, Single_ID_0 );
}
/*********************************************END OF FILE**********************/

